package binarytree;

import java.util.ArrayList;
import java.util.List;

import binarytree.BinaryTree.Node;

//二叉排序树，也叫二叉搜索树（存放整数，也可存放其他对象，
//只要能进行某种性质上的大小比较）
//根据整数大小来存放，比父节点小的总是为父节点左边
//比父节点大的总是为父节点的右边节点
public class BinarySearchTree {
	private class Node{
		int data;
		Node left;
		Node right;
		public Node(){};
		public Node(int element){
			this.data = element;
			left = right = null;
		}
		public Node(int element,Node left,Node right){
			this(element);
			this.left = left;
			this.right = right;
		}
	}
	private Node root;
	public BinarySearchTree(){
		root = null;
	};
	//以根节点创建二叉搜索树
	public BinarySearchTree(int element){
		root = new Node(element);
	}
	//插入操作
	public void insert(int element){
		if(root == null){
			root = new Node(element);
		}else{
			Node current = root;
			Node parent = null;
			Node newNode = new Node(element,null,null);
			//该变量标记新节点在左还是在右
			boolean isLeft = false;
			//寻找一个合适的位置作为插入点
			while(current != null){
				parent = current;
				//如果新插入的节点大于当前的节点
				if(element > current.data){
					//则把当前节点右移
					current = current.right;
					isLeft = false;
				}else{
					//如果新节点小于等于当前节点，则把当前节点左移
					current = current.left;
					isLeft = true;
				}
			}
			//如果是在左，则新节点放到最后一次parent的左边
			if(isLeft){
				parent.left = newNode;
			}else{
				parent.right = newNode;
			}
			
		}
		
	}
	
	//[重要]中序遍历:先遍历左子节点
	public void middleVisit(){
		List<Node> list = new ArrayList<>();
		list = middleVisit(root);
		for(int i=0;i<list.size();i++){
			System.out.print(list.get(i).data+" ");
		}
	}
	public List<Node> middleVisit(Node node){
		List<Node> tmpList = new ArrayList<>();
		//递归处理左子树
		if(node.left != null){
			tmpList.addAll(middleVisit(node.left));
		}
		tmpList.add(node);
		if(node.right != null){
			tmpList.addAll(middleVisit(node.right));
		}
		return tmpList;
	}
	public static void main(String[] args) {
		BinarySearchTree BSTree = new BinarySearchTree();
		BSTree.insert(6);
		BSTree.insert(13);
		BSTree.insert(2);
		BSTree.insert(25);
		BSTree.insert(36);
		BSTree.middleVisit();
	}

}

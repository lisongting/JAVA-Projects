package binarytree;

/**红黑树：是一种特殊的二叉搜索树
 * 红黑树的特性:
 *	(1) 每个节点或者是黑色，或者是红色。
 *	(2) 根节点是黑色。
 *	(3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]
 *	(4) 如果一个节点是红色的，则它的子节点必须是黑色的。
 *	(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。
 * @author Administrator
 *
 */
public class RedBlackTree {
	private static final boolean RED = false;
	private static final boolean BLACK = true;
	private class Node{
		int data;
		boolean color;
		Node parent;
		Node left;
		Node right;
		public Node(int data,Node parent,Node left,Node right){
			this.data = data;
			this.parent = parent;
			this.left = left;
			this.right = right;
		}
		public String toString(){
			return "["+data+" "+color+"]";
		};
	}
	
	private Node root;
	public RedBlackTree(){
		root = null;
	}
	public RedBlackTree(int data){
		root = new Node(data,null,null,null);
	}
	//[重要]添加节点
	public void insert(int val){
		if(root == null){
			root = new Node(val,null,null,null);
		}else{
			Node current = root;
			Node parent = null;
			while(current != null){
				parent = current;
				if(val > current.data){
					current = current.right;
				}else{
					current = current.left;
				}
			}
			Node newNode = new Node(val,parent,null,null);
			//如果新节点大于parent，则放在parent的右边
			if(parent.data < val){
				parent.right = newNode;
			}else{
				//如果新节点小于parent，则放在parent左边
				parent.left = newNode;
			}
			fixAfterInsertation(newNode);
		}
		
	}
	//[重要]删除节点的操作
	public void remove(int val){
		
	}
	/* 
	 * 对红黑树的节点(x)进行左旋转
	 * 左旋示意图(对节点x进行左旋)：
	 *      px                              px
	 *     /                                /
	 *     x                               y                
	 *   /   \      --(左旋)-.           /   \                
	 *  lx    y                         x     ry     
	 *       /  \                     /  \
	 *      ly   ry                  lx   ly  
	 *
	 */
	public void leftRotate(Node x){
		Node y = x.right;
		//将x的右节点设为y的左节点
		x.right = y.left;
		
	}
	
	
	//插入后修复红黑树
	public void fixAfterInsertation(Node x){
		x.color = RED;//为什么先默认设为红色？
		//当x的父节点不是根，并且x的父节点不是红色。进行循环
		while(x!=null && x!=root && x.parent.color == RED){
			
		}
	}
	public void fixAfterDeletion(){
		
	}
	//根据指定的值查找节点
	public Node findNode(int val){
		if(root == null){
			return null;
		}
		Node p = root;
		while(p!=null){
			if(p.data < val){
				p = p.right;
			}else if(p.data > val){
				p = p.right;
			}else{
				return p;
			}
		}
		return null;
	}
	
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}

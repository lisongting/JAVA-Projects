package sort;

import java.util.Arrays;
/**
 * 堆排序
 * （属于选择排序）
 * 时间复杂度：O(nlogn) 
 * 空间复杂度:O(1)
 * 稳定性：不稳定
 * [分析]堆中每次都只取出第0个数据，通过　
 * 重建堆（从根结点开始进行一次从上向下的调整。)
 * 找出最大的元素放在一个节点的位置
 * 然后再取，如此重复实现排序
 * @author Administrator
 */
public class HeapSort {
	
	public static void heapSort(int[] array){
		//先把array数组构建成一个大顶堆
		//从完全二叉树最右边的叶子节点的父节点开始
		for(int i = array.length/2-1;i>=0;i--){
			moveDown(array,i,array.length-1);
		}
		//接下来进行堆排序
		for(int i =array.length-1;i>=1;i--){
			//将未排序的末尾元素与堆顶元素交换
			swap(array,0,i);
			//进行堆排序
			moveDown(array,0,i-1);
		}
	}
	//每一次moveDown都会把未排序区中最大的数挑出来放在堆顶
	public static void moveDown(int[] array,int first,int last){
		//将first的左子节点设为largest
		int largest = first*2 +1;
		while(largest <= last){
			//如果first的右子节点大于左子节点
			if(largest<last&&array[largest]<array[largest+1]){
				//标记较大的那个右子节点
				largest++;
			}
			//如果第一个元素小于largest元素
			if(array[first]<array[largest]){
				//将first和largest对应的元素进行交换
				swap(array,first,largest);
				
				//继续往下移动
				first = largest;
				largest = 2*first+1;
			}else{
				//如果该节点比它的两个孩子都大，则退出循环
				break;
			}
		}
	}
	
	public static void swap(int[] array,int i,int j){
		int tmp = array[i];
		array[i] = array[j];
		array[j] = tmp;
	}
	
	public static void main(String[] args) {
		int[] array = new int[]{9,5,23,2,0,21,30,13};
		System.out.println("排序前：\n"+Arrays.toString(array));
		System.out.println("开始排序：");
		heapSort(array);
		System.out.println("排序后：\n"+Arrays.toString(array));

	}

}

package binarytree;

import java.util.ArrayList;
import java.util.List;

import binarytree.BinaryTree.Node;

//二叉排序树，也叫二叉搜索树（存放整数，也可存放其他对象，
//只要能进行某种性质上的大小比较）
//根据整数大小来存放，比父节点小的总是为父节点左边
//比父节点大的总是为父节点的右边节点
public class BinarySearchTree {
	private class Node{
		int data;
		Node left;
		Node right;
		public Node(){};
		public Node(int element){
			this.data = element;
			left = right = null;
		}
		public Node(int element,Node left,Node right){
			this(element);
			this.left = left;
			this.right = right;
		}
	}
	private Node root;
	public BinarySearchTree(){
		root = null;
	};
	//以根节点创建二叉搜索树
	public BinarySearchTree(int element){
		root = new Node(element);
	}
	//[重要]插入操作
	public void insert(int element){
		if(root == null){
			root = new Node(element);
		}else{
			Node current = root;
			Node parent = null;
			Node newNode = new Node(element,null,null);
			//该变量标记新节点在左还是在右
			boolean isLeft = false;
			//寻找一个合适的位置作为插入点
			while(current != null){
				parent = current;
				//如果新插入的节点大于当前的节点
				if(element > current.data){
					//则把当前节点右移
					current = current.right;
					isLeft = false;
				}else{
					//如果新节点小于等于当前节点，则把当前节点左移
					current = current.left;
					isLeft = true;
				}
			}
			//如果是在左，则新节点放到最后一次parent的左边
			if(isLeft){
				parent.left = newNode;
			}else{
				parent.right = newNode;
			}
		}
	}
	//[重要]删除操作
	public void remove(int element){
		Node delNode = findNode(element);//先找到要删除的节点
		if(delNode == null){
			return;
		}
		//然后进行树结构调整操作
		//如果要删除的节点没有左右子节点，即它本身就是叶子节点
		if(delNode.left == null && delNode.right==null){
			delNode = null;
			//先试试不删除父节点的left/right
			//
			//.....
		}
		//如果要删除的节点只有左子节点
		else if(delNode.left!=null && delNode.right==null){
			
			
		}
		//如果要删除的节点只有右子节点
		else if(delNode.left==null && delNode.right!=null){
			if(delNode == root){
				
			}
		}
		//如果要删除的节点有左右节点
		else{
			
		}
		
	}
	//根据数字查找节点
	public Node findNode(int element){
		if(root == null){
			return null;
		}
		Node p = root;
		while(p!=null){
			if(element > p.data){
				p = p.right;
			}else if(element < p.data){
				p = p.left;
			}else{
				return p;
			}
		}
		return null;
	}
	//找到一个节点的父节点
	public Node findParent(Node child){
		if(child == null){
			return null;
		}
		if(child == root){
			return null;
		}
		Node current = root;
		Node prev = current;
		while(current != child && current!= null){
			if(current.data < child.data){
				prev = current;
				System.out.println("prev为："+prev.data);
				System.out.println("current右移");
				current = current.right;
			}else if(current.data > child.data){
				prev = current;
				System.out.println("prev为："+prev.data);
				System.out.println("current左移");
				current = current.left;
			}else{
				System.out.println("prev为："+prev.data);
				return prev;
			}
		}
		return null;
	}
	//[重要]中序遍历:先遍历左子节点
	public void middleVisit(){
		List<Node> list = new ArrayList<>();
		list = middleVisit(root);
		for(int i=0;i<list.size();i++){
			System.out.print(list.get(i).data+" ");
		}
	}
	public List<Node> middleVisit(Node node){
		List<Node> tmpList = new ArrayList<>();
		//递归处理左子树
		if(node.left != null){
			tmpList.addAll(middleVisit(node.left));
		}
		tmpList.add(node);
		if(node.right != null){
			tmpList.addAll(middleVisit(node.right));
		}
		return tmpList;
	}
	/**
	 * 初始化建立起来的树为
	 *           6
	 *         /  \
	 *        2   13
	 *         \  / \
	 *          5 8	25
	 *       	     \
	 *                36
	 * @param args
	 */
	public static void main(String[] args) {
		BinarySearchTree BSTree = new BinarySearchTree();
		BSTree.insert(6);
		BSTree.insert(13);
		BSTree.insert(2);
		BSTree.insert(25);
		BSTree.insert(36);
		BSTree.insert(8);
		BSTree.insert(5);
		BSTree.middleVisit();
		System.out.println("8的父节点为"+BSTree.findParent(BSTree.findNode(8)).data);
	}

}

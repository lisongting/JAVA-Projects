package sort;

import java.util.Arrays;
/**
 * 堆排序
 * （属于选择排序）
 * 时间复杂度：O(nlogn) 
 * 空间复杂度:O(1)
 * 稳定性：不稳定
 * [分析]堆中每次都只取出第0个数据，通过　
 * 重建堆（从根结点开始进行一次从上向下的调整。)
 * 找出最大的元素放在一个节点的位置
 * 然后再取，如此重复实现排序
 * @author Administrator
 */
public class HepSort {
	public static void heapSort(int[] array){
		for(int i=0;i<array.length-1;i++){
			//因为每次buildMaxHeap之后，都会在堆顶形成一个最大
			//的节点，要用这个最大值与未排序的堆尾元素交换，
			//因此第二个参数要每次减少1
			buildMaxHeap(array,array.length-1-i);
			//交换堆顶和最后一个元素
			swap(array,0,array.length-1-i);
			System.out.println(Arrays.toString(array));
		}
	}
	
	//建立最大顶堆
	public static void buildMaxHeap(int[] array,int lastIndex){
		//从最后一个节点的父节点开始，其父节点是(lastIndex-1)/2
		for(int i= (lastIndex-1)/2;i>=0;i--){
			//保存当前正在判断的节点
			int k = i;
			//最大堆是一个完全二叉树
			//节点k的子节点为2K+1和2k+2
			//如果当前k的子节点存在
			while(k*2+1 <= lastIndex){
				//k的左子节点
				int biggerIndex = 2*k+1;
				//如果biggerIndex小于lastIndex,则biggerIndex加一
				//表示k的右节点存在且大于其左节点
				if(biggerIndex<lastIndex){
					if(array[lastIndex]>array[biggerIndex]){
						//biggerIndex总是指向较大的子节点
						biggerIndex++;
					}
				}
				//如果k节点的值小于其较大子节点的值
				if(array[k]<array[biggerIndex]){
					//交换它们
					swap(array,k,biggerIndex);
					//将biggerIndex赋给k，开始while循环的下一次循环
					//重新保证k节点的值大于其左右节点的值
					k = biggerIndex;
				}else{
					break;
				}
			}
		}
	}
	
	public static void swap(int[] array,int i,int j){
		int tmp = array[i];
		array[i] = array[j];
		array[j] = tmp;
	}
	
	public static void main(String[] args) {
		int[] array = new int[]{9,5,23,2,0,21,30,13};
		System.out.println("排序前：\n"+Arrays.toString(array));
		System.out.println("开始排序：");
		
		System.out.println("排序后：\n"+Arrays.toString(array));

	}

}

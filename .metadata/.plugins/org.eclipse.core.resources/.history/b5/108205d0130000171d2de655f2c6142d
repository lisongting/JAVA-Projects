package sort;

import java.util.Arrays;
/**
 * 堆排序
 * （属于选择排序）
 * 时间复杂度：O(nlogn) 
 * 空间复杂度:O(1)
 * 稳定性：不稳定
 * [分析]堆中每次都只取出第0个数据，通过　
 * 重建堆（从根结点开始进行一次从上向下的调整。)
 * 找出最大的元素放在一个节点的位置
 * 然后再取，如此重复实现排序
 * @author Administrator
 */
public class HeapSort {
	
	public static void heapSort(int[] array){
		//先把array数组构建成一个大顶堆
		//从完全二叉树最右边的叶子节点的父节点开始
		for(int i = array.length/2-1;i>=0;i--){
			moveDown(array,i,array.length);
		}
	}
	
	public static void moveDown(int[] array,int first,int last){
		
	}
	
	public static void swap(int[] array,int i,int j){
		int tmp = array[i];
		array[i] = array[j];
		array[j] = tmp;
	}
	
	public static void main(String[] args) {
		int[] array = new int[]{9,5,23,2,0,21,30,13};
		System.out.println("排序前：\n"+Arrays.toString(array));
		System.out.println("开始排序：");
		heapSort(array);
		System.out.println("排序后：\n"+Arrays.toString(array));

	}

}

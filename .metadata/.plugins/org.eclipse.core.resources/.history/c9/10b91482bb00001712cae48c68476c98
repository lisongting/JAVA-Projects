package sort;

import java.util.ArrayDeque;
import java.util.Arrays;

/**
 * 归并排序
 * 时间复杂度：O(nlogn)^2 
 * 空间复杂度:O(1)
 * 稳定性：稳定
 * [分析]
 * @author Administrator
 */
public class MergeSort {

	
	//left是待排序数组的第一个位置索引，right是最后一个位置索引
	public static void mergeSort(int[] array){
		int len = array.length;
		//用于合并的临时数组
		int[] result = new int[len];
		int block ,start;
		
		//块大小先从1开始，两个元素两两合并
		//两两合并后，块大小变为两倍
		//两个块为一组
		for(block=1; block<=len; block*=2){
			//把整个数组分成很多个块，每次合并处理两个块
			//start是每个分块左边的位置
			for(start= 0;start<len;start+=block){
				int low = start;
				//第一块的起始low,终止mid
				//如果start+block不超过len,则mid就为start+block
				int mid = (start+block)<len ? (start+block) : len;
				//第二块的起始mid，终止high
				int high = (start+2*block)<len?(start+2*block):len;
				
				//两个块的起始和终止位置索引
				int start1 = low;   int end1 = mid;
				int start2 = mid; int end2 = high;
				//开始对两个块进行归并排序
				while(start1<end1 && start2<end2){
					if(array[start1] < array[start2]){
						result[low] = array[start1]; 
						low++;
						start1++;
					}else{
						result[low] = array[start2];
						low++;
						start2++;
					}
				}
				while(start1<end1){
					result[low++] =array[start1++]; 
				}
				while(start2<end2){
					result[low++] = array[start2++];
				}
			}
			//每次归并完后，将结果存在回array中，方便下次归并
			int[] tmp = array;
			array = result;
			result = tmp;
			System.out.println(Arrays.toString(array));
		}
	}
	
	public static void main(String[] args) {
		int[] array = new int[]{9,5,23,2,0,21,30,13};
		System.out.println("排序前：\n"+Arrays.toString(array));
		System.out.println("开始排序：");
		mergeSort(array);
		System.out.println("排序后：\n"+Arrays.toString(array));
	}

}
